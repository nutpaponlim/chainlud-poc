import { atom, selector, DefaultValue, useRecoilValue, useResetRecoilState, useSetRecoilState, useRecoilState } from 'recoil';
import { isEqual, debounce } from 'lodash';
import { v4 } from 'uuid';
import { createContext, useContext, useMemo, useCallback, useEffect, useRef } from 'react';
import Lt, { SWRConfig } from 'swr';
import Qt from 'socket.io-client';
export { Socket } from 'socket.io-client';
import { toast } from 'sonner';

var $e=o=>{let e={},t=new Date;return t.setHours(0,0,0,0),[...o].sort((s,r)=>new Date(r.createdAt).getTime()-new Date(s.createdAt).getTime()).forEach(s=>{let r=new Date(s.createdAt);r.setHours(0,0,0,0);let n=Math.floor((t.getTime()-r.getTime())/864e5),a;n===0?a="Today":n===1?a="Yesterday":n<=7?a="Previous 7 days":n<=30?a="Previous 30 days":a=r.toLocaleString("default",{month:"long",year:"numeric"}),e[a]??(e[a]=[]),e[a].push(s);}),e};var Ne=[4186.01,4434.92,4698.63,4978.03,5274.04,5587.65,5919.91,6271.93,6644.88,7040,7458.62,7902.13],xt=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"],_=[],le=[];for(let o=1;o<=8;o++)for(let e=0;e<Ne.length;e++){let t=Ne[e];_.push(t/Math.pow(2,8-o)),le.push(xt[e]+o);}var ue=[32,2e3],Me=_.filter((o,e)=>_[e]>ue[0]&&_[e]<ue[1]),ze=le.filter((o,e)=>_[e]>ue[0]&&_[e]<ue[1]);var B=class o{static getFrequencies(e,t,s,r="frequency",n=-100,a=-30){s||(s=new Float32Array(e.frequencyBinCount),e.getFloatFrequencyData(s));let c=t/2,u=1/s.length*c,p,f,d;if(r==="music"||r==="voice"){let S=r==="voice"?Me:_,w=Array(S.length).fill(n);for(let F=0;F<s.length;F++){let se=F*u,V=s[F];for(let v=S.length-1;v>=0;v--)if(se>S[v]){w[v]=Math.max(w[v],V);break}}p=w,f=r==="voice"?Me:_,d=r==="voice"?ze:le;}else p=Array.from(s),f=p.map((S,w)=>u*w),d=f.map(S=>`${S.toFixed(2)} Hz`);let g=p.map(S=>Math.max(0,Math.min((S-n)/(a-n),1)));return {values:new Float32Array(g),frequencies:f,labels:d}}constructor(e,t=null){if(this.fftResults=[],t){let{length:s,sampleRate:r}=t,n=new OfflineAudioContext({length:s,sampleRate:r}),a=n.createBufferSource();a.buffer=t;let c=n.createAnalyser();c.fftSize=8192,c.smoothingTimeConstant=.1,a.connect(c);let u=1/60,p=s/r,f=d=>{let g=u*d;g<p&&n.suspend(g).then(()=>{let y=new Float32Array(c.frequencyBinCount);c.getFloatFrequencyData(y),this.fftResults.push(y),f(d+1);}),d===1?n.startRendering():n.resume();};a.start(0),f(1),this.audio=e,this.context=n,this.analyser=c,this.sampleRate=r,this.audioBuffer=t;}else {let s=new AudioContext,r=s.createMediaElementSource(e),n=s.createAnalyser();n.fftSize=8192,n.smoothingTimeConstant=.1,r.connect(n),n.connect(s.destination),this.audio=e,this.context=s,this.analyser=n,this.sampleRate=this.context.sampleRate,this.audioBuffer=null;}}getFrequencies(e="frequency",t=-100,s=-30){let r=null;if(this.audioBuffer&&this.fftResults.length){let n=this.audio.currentTime/this.audio.duration,a=Math.min(n*this.fftResults.length|0,this.fftResults.length-1);r=this.fftResults[a];}return o.getFrequencies(this.analyser,this.sampleRate,r,e,t,s)}async resumeIfSuspended(){return this.context.state==="suspended"&&await this.context.resume(),!0}};globalThis.AudioAnalysis=B;var T=class{static floatTo16BitPCM(e){let t=new ArrayBuffer(e.length*2),s=new DataView(t),r=0;for(let n=0;n<e.length;n++,r+=2){let a=Math.max(-1,Math.min(1,e[n]));s.setInt16(r,a<0?a*32768:a*32767,!0);}return t}static mergeBuffers(e,t){let s=new Uint8Array(e.byteLength+t.byteLength);return s.set(new Uint8Array(e),0),s.set(new Uint8Array(t),e.byteLength),s.buffer}_packData(e,t){return [new Uint8Array([t,t>>8]),new Uint8Array([t,t>>8,t>>16,t>>24])][e]}pack(e,t){if(t?.bitsPerSample)if(t?.channels){if(!t?.data)throw new Error('Missing "data"')}else throw new Error('Missing "channels"');else throw new Error('Missing "bitsPerSample"');let{bitsPerSample:s,channels:r,data:n}=t,a=["RIFF",this._packData(1,4+(8+24)+(8+8)),"WAVE","fmt ",this._packData(1,16),this._packData(0,1),this._packData(0,r.length),this._packData(1,e),this._packData(1,e*r.length*s/8),this._packData(0,r.length*s/8),this._packData(0,s),"data",this._packData(1,r[0].length*r.length*s/8),n],c=new Blob(a,{type:"audio/mpeg"}),u=URL.createObjectURL(c);return {blob:c,url:u,channelCount:r.length,sampleRate:e,duration:n.byteLength/(r.length*e*2)}}};globalThis.WavPacker=T;var vt=`
class AudioProcessor extends AudioWorkletProcessor {

  constructor() {
    super();
    this.port.onmessage = this.receive.bind(this);
    this.initialize();
  }

  initialize() {
    this.foundAudio = false;
    this.recording = false;
    this.chunks = [];
  }

  /**
   * Concatenates sampled chunks into channels
   * Format is chunk[Left[], Right[]]
   */
  readChannelData(chunks, channel = -1, maxChannels = 9) {
    let channelLimit;
    if (channel !== -1) {
      if (chunks[0] && chunks[0].length - 1 < channel) {
        throw new Error(
          \`Channel \${channel} out of range: max \${chunks[0].length}\`
        );
      }
      channelLimit = channel + 1;
    } else {
      channel = 0;
      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);
    }
    const channels = [];
    for (let n = channel; n < channelLimit; n++) {
      const length = chunks.reduce((sum, chunk) => {
        return sum + chunk[n].length;
      }, 0);
      const buffers = chunks.map((chunk) => chunk[n]);
      const result = new Float32Array(length);
      let offset = 0;
      for (let i = 0; i < buffers.length; i++) {
        result.set(buffers[i], offset);
        offset += buffers[i].length;
      }
      channels[n] = result;
    }
    return channels;
  }

  /**
   * Combines parallel audio data into correct format,
   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]
   */
  formatAudioData(channels) {
    if (channels.length === 1) {
      // Simple case is only one channel
      const float32Array = channels[0].slice();
      const meanValues = channels[0].slice();
      return { float32Array, meanValues };
    } else {
      const float32Array = new Float32Array(
        channels[0].length * channels.length
      );
      const meanValues = new Float32Array(channels[0].length);
      for (let i = 0; i < channels[0].length; i++) {
        const offset = i * channels.length;
        let meanValue = 0;
        for (let n = 0; n < channels.length; n++) {
          float32Array[offset + n] = channels[n][i];
          meanValue += channels[n][i];
        }
        meanValues[i] = meanValue / channels.length;
      }
      return { float32Array, meanValues };
    }
  }

  /**
   * Converts 32-bit float data to 16-bit integers
   */
  floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    let offset = 0;
    for (let i = 0; i < float32Array.length; i++, offset += 2) {
      let s = Math.max(-1, Math.min(1, float32Array[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
    return buffer;
  }

  /**
   * Retrieves the most recent amplitude values from the audio stream
   * @param {number} channel
   */
  getValues(channel = -1) {
    const channels = this.readChannelData(this.chunks, channel);
    const { meanValues } = this.formatAudioData(channels);
    return { meanValues, channels };
  }

  /**
   * Exports chunks as an audio/wav file
   */
  export() {
    const channels = this.readChannelData(this.chunks);
    const { float32Array, meanValues } = this.formatAudioData(channels);
    const audioData = this.floatTo16BitPCM(float32Array);
    return {
      meanValues: meanValues,
      audio: {
        bitsPerSample: 16,
        channels: channels,
        data: audioData,
      },
    };
  }

  receive(e) {
    const { event, id } = e.data;
    let receiptData = {};
    switch (event) {
      case 'start':
        this.recording = true;
        break;
      case 'stop':
        this.recording = false;
        break;
      case 'clear':
        this.initialize();
        break;
      case 'export':
        receiptData = this.export();
        break;
      case 'read':
        receiptData = this.getValues();
        break;
      default:
        break;
    }
    // Always send back receipt
    this.port.postMessage({ event: 'receipt', id, data: receiptData });
  }

  sendChunk(chunk) {
    const channels = this.readChannelData([chunk]);
    const { float32Array, meanValues } = this.formatAudioData(channels);
    const rawAudioData = this.floatTo16BitPCM(float32Array);
    const monoAudioData = this.floatTo16BitPCM(meanValues);
    this.port.postMessage({
      event: 'chunk',
      data: {
        mono: monoAudioData,
        raw: rawAudioData,
      },
    });
  }

  process(inputList, outputList, parameters) {
    // Copy input to output (e.g. speakers)
    // Note that this creates choppy sounds with Mac products
    const sourceLimit = Math.min(inputList.length, outputList.length);
    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {
      const input = inputList[inputNum];
      const output = outputList[inputNum];
      const channelCount = Math.min(input.length, output.length);
      for (let channelNum = 0; channelNum < channelCount; channelNum++) {
        input[channelNum].forEach((sample, i) => {
          output[channelNum][i] = sample;
        });
      }
    }
    const inputs = inputList[0];
    // There's latency at the beginning of a stream before recording starts
    // Make sure we actually receive audio data before we start storing chunks
    let sliceIndex = 0;
    if (!this.foundAudio) {
      for (const channel of inputs) {
        sliceIndex = 0; // reset for each channel
        if (this.foundAudio) {
          break;
        }
        if (channel) {
          for (const value of channel) {
            if (value !== 0) {
              // find only one non-zero entry in any channel
              this.foundAudio = true;
              break;
            } else {
              sliceIndex++;
            }
          }
        }
      }
    }
    if (inputs && inputs[0] && this.foundAudio && this.recording) {
      // We need to copy the TypedArray, because the \`process\`
      // internals will reuse the same buffer to hold each input
      const chunk = inputs.map((input) => input.slice(sliceIndex));
      this.chunks.push(chunk);
      this.sendChunk(chunk);
    }
    return true;
  }
}

registerProcessor('audio_processor', AudioProcessor);
`,Tt=new Blob([vt],{type:"application/javascript"}),Pt=URL.createObjectURL(Tt),He=Pt;var N=class{constructor({sampleRate:e=24e3,outputToSpeakers:t=!1,debug:s=!1}={}){this.scriptSrc=He,this.sampleRate=e,this.outputToSpeakers=t,this.debug=!!s,this._deviceChangeCallback=null,this._devices=[],this.stream=null,this.processor=null,this.source=null,this.node=null,this.recording=!1,this._lastEventId=0,this.eventReceipts={},this.eventTimeout=5e3,this._chunkProcessor=()=>{},this._chunkProcessorSize=void 0,this._chunkProcessorBuffer={raw:new ArrayBuffer(0),mono:new ArrayBuffer(0)};}static async decode(e,t=24e3,s=-1){let r=new AudioContext({sampleRate:t}),n,a;if(e instanceof Blob){if(s!==-1)throw new Error('Can not specify "fromSampleRate" when reading from Blob');a=e,n=await a.arrayBuffer();}else if(e instanceof ArrayBuffer){if(s!==-1)throw new Error('Can not specify "fromSampleRate" when reading from ArrayBuffer');n=e,a=new Blob([n],{type:"audio/wav"});}else {let f,d;if(e instanceof Int16Array){d=e,f=new Float32Array(e.length);for(let w=0;w<e.length;w++)f[w]=e[w]/32768;}else if(e instanceof Float32Array)f=e;else if(e instanceof Array)f=new Float32Array(e);else throw new Error('"audioData" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>');if(s===-1)throw new Error('Must specify "fromSampleRate" when reading from Float32Array, In16Array or Array');if(s<3e3)throw new Error('Minimum "fromSampleRate" is 3000 (3kHz)');d||(d=T.floatTo16BitPCM(f));let g={bitsPerSample:16,channels:[f],data:d};a=new T().pack(s,g).blob,n=await a.arrayBuffer();}let c=await r.decodeAudioData(n),u=c.getChannelData(0),p=URL.createObjectURL(a);return {blob:a,url:p,values:u,audioBuffer:c}}log(){return this.debug&&this.log(...arguments),!0}getSampleRate(){return this.sampleRate}getStatus(){return this.processor?this.recording?"recording":"paused":"ended"}async _event(e,t={},s=null){if(s=s||this.processor,!s)throw new Error("Can not send events without recording first");let r={event:e,id:this._lastEventId++,data:t};s.port.postMessage(r);let n=new Date().valueOf();for(;!this.eventReceipts[r.id];){if(new Date().valueOf()-n>this.eventTimeout)throw new Error(`Timeout waiting for "${e}" event`);await new Promise(c=>setTimeout(()=>c(!0),1));}let a=this.eventReceipts[r.id];return delete this.eventReceipts[r.id],a}listenForDeviceChange(e){if(e===null&&this._deviceChangeCallback)navigator.mediaDevices.removeEventListener("devicechange",this._deviceChangeCallback),this._deviceChangeCallback=null;else if(e!==null){let t=0,s=[],r=a=>a.map(c=>c.deviceId).sort().join(","),n=async()=>{let a=++t,c=await this.listDevices();a===t&&r(s)!==r(c)&&(s=c,e(c.slice()));};navigator.mediaDevices.addEventListener("devicechange",n),n(),this._deviceChangeCallback=n;}return !0}async requestPermission(){let e=await navigator.permissions.query({name:"microphone"});if(e.state==="denied")window.alert("You must grant microphone access to use this feature.");else if(e.state==="prompt")try{(await navigator.mediaDevices.getUserMedia({audio:!0})).getTracks().forEach(r=>r.stop());}catch{window.alert("You must grant microphone access to use this feature.");}return !0}async listDevices(){if(!navigator.mediaDevices||!("enumerateDevices"in navigator.mediaDevices))throw new Error("Could not request user devices");await this.requestPermission();let t=(await navigator.mediaDevices.enumerateDevices()).filter(n=>n.kind==="audioinput"),s=t.findIndex(n=>n.deviceId==="default"),r=[];if(s!==-1){let n=t.splice(s,1)[0],a=t.findIndex(c=>c.groupId===n.groupId);a!==-1&&(n=t.splice(a,1)[0]),n.default=!0,r.push(n);}return r.concat(t)}async begin(e){if(this.processor)throw new Error("Already connected: please call .end() to start a new session");if(!navigator.mediaDevices||!("getUserMedia"in navigator.mediaDevices))throw new Error("Could not request user media");try{let c={audio:!0};e&&(c.audio={deviceId:{exact:e}}),this.stream=await navigator.mediaDevices.getUserMedia(c);}catch{throw new Error("Could not start media stream")}let t=new AudioContext({sampleRate:this.sampleRate}),s=t.createMediaStreamSource(this.stream);try{await t.audioWorklet.addModule(this.scriptSrc);}catch(c){throw console.error(c),new Error(`Could not add audioWorklet module: ${this.scriptSrc}`)}let r=new AudioWorkletNode(t,"audio_processor");r.port.onmessage=c=>{let{event:u,id:p,data:f}=c.data;if(u==="receipt")this.eventReceipts[p]=f;else if(u==="chunk")if(this._chunkProcessorSize){let d=this._chunkProcessorBuffer;this._chunkProcessorBuffer={raw:T.mergeBuffers(d.raw,f.raw),mono:T.mergeBuffers(d.mono,f.mono)},this._chunkProcessorBuffer.mono.byteLength>=this._chunkProcessorSize&&(this._chunkProcessor(this._chunkProcessorBuffer),this._chunkProcessorBuffer={raw:new ArrayBuffer(0),mono:new ArrayBuffer(0)});}else this._chunkProcessor(f);};let n=s.connect(r),a=t.createAnalyser();return a.fftSize=8192,a.smoothingTimeConstant=.1,n.connect(a),this.outputToSpeakers&&(console.warn(`Warning: Output to speakers may affect sound quality,
especially due to system audio feedback preventative measures.
use only for debugging`),a.connect(t.destination)),this.source=s,this.node=n,this.analyser=a,this.processor=r,!0}getFrequencies(e="frequency",t=-100,s=-30){if(!this.processor)throw new Error("Session ended: please call .begin() first");return B.getFrequencies(this.analyser,this.sampleRate,null,e,t,s)}async pause(){if(this.processor){if(!this.recording)throw new Error("Already paused: please call .record() first")}else throw new Error("Session ended: please call .begin() first");return this._chunkProcessorBuffer.raw.byteLength&&this._chunkProcessor(this._chunkProcessorBuffer),this.log("Pausing ..."),await this._event("stop"),this.recording=!1,!0}async record(e=()=>{},t=8192){if(this.processor){if(this.recording)throw new Error("Already recording: please call .pause() first");if(typeof e!="function")throw new Error("chunkProcessor must be a function")}else throw new Error("Session ended: please call .begin() first");return this._chunkProcessor=e,this._chunkProcessorSize=t,this._chunkProcessorBuffer={raw:new ArrayBuffer(0),mono:new ArrayBuffer(0)},this.log("Recording ..."),await this._event("start"),this.recording=!0,!0}async clear(){if(!this.processor)throw new Error("Session ended: please call .begin() first");return await this._event("clear"),!0}async read(){if(!this.processor)throw new Error("Session ended: please call .begin() first");return this.log("Reading ..."),await this._event("read")}async save(e=!1){if(!this.processor)throw new Error("Session ended: please call .begin() first");if(!e&&this.recording)throw new Error("Currently recording: please call .pause() first, or call .save(true) to force");this.log("Exporting ...");let t=await this._event("export");return new T().pack(this.sampleRate,t.audio)}async end(){if(!this.processor)throw new Error("Session ended: please call .begin() first");let e=this.processor;this.log("Stopping ..."),await this._event("stop"),this.recording=!1,this.stream.getTracks().forEach(a=>a.stop()),this.log("Exporting ...");let s=await this._event("export",{},e);return this.processor.disconnect(),this.source.disconnect(),this.node.disconnect(),this.analyser.disconnect(),this.stream=null,this.processor=null,this.source=null,this.node=null,new T().pack(this.sampleRate,s.audio)}async quit(){return this.listenForDeviceChange(null),this.processor&&await this.end(),!0}};globalThis.WavRecorder=N;var Mt=`
class StreamProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.hasStarted = false;
    this.hasInterrupted = false;
    this.outputBuffers = [];
    this.bufferLength = 128;
    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };
    this.writeOffset = 0;
    this.trackSampleOffsets = {};
    this.port.onmessage = (event) => {
      if (event.data) {
        const payload = event.data;
        if (payload.event === 'write') {
          const int16Array = payload.buffer;
          const float32Array = new Float32Array(int16Array.length);
          for (let i = 0; i < int16Array.length; i++) {
            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32
          }
          this.writeData(float32Array, payload.trackId);
        } else if (
          payload.event === 'offset' ||
          payload.event === 'interrupt'
        ) {
          const requestId = payload.requestId;
          const trackId = this.write.trackId;
          const offset = this.trackSampleOffsets[trackId] || 0;
          this.port.postMessage({
            event: 'offset',
            requestId,
            trackId,
            offset,
          });
          if (payload.event === 'interrupt') {
            this.hasInterrupted = true;
          }
        } else {
          throw new Error(\`Unhandled event "\${payload.event}"\`);
        }
      }
    };
  }

  writeData(float32Array, trackId = null) {
    let { buffer } = this.write;
    let offset = this.writeOffset;
    for (let i = 0; i < float32Array.length; i++) {
      buffer[offset++] = float32Array[i];
      if (offset >= buffer.length) {
        this.outputBuffers.push(this.write);
        this.write = { buffer: new Float32Array(this.bufferLength), trackId };
        buffer = this.write.buffer;
        offset = 0;
      }
    }
    this.writeOffset = offset;
    return true;
  }

  process(inputs, outputs, parameters) {
    const output = outputs[0];
    const outputChannelData = output[0];
    const outputBuffers = this.outputBuffers;
    if (this.hasInterrupted) {
      this.port.postMessage({ event: 'stop' });
      return false;
    } else if (outputBuffers.length) {
      this.hasStarted = true;
      const { buffer, trackId } = outputBuffers.shift();
      for (let i = 0; i < outputChannelData.length; i++) {
        outputChannelData[i] = buffer[i] || 0;
      }
      if (trackId) {
        this.trackSampleOffsets[trackId] =
          this.trackSampleOffsets[trackId] || 0;
        this.trackSampleOffsets[trackId] += buffer.length;
      }
      return true;
    } else if (this.hasStarted) {
      this.port.postMessage({ event: 'stop' });
      return false;
    } else {
      return true;
    }
  }
}

registerProcessor('stream_processor', StreamProcessor);
`,Et=new Blob([Mt],{type:"application/javascript"}),_t=URL.createObjectURL(Et),We=_t;var z=class{constructor({sampleRate:e=24e3,onStop:t}={}){this.scriptSrc=We,this.onStop=t,this.sampleRate=e,this.context=null,this.stream=null,this.analyser=null,this.trackSampleOffsets={},this.interruptedTrackIds={};}async connect(){this.context=new AudioContext({sampleRate:this.sampleRate}),this.context.state==="suspended"&&await this.context.resume();try{await this.context.audioWorklet.addModule(this.scriptSrc);}catch(t){throw console.error(t),new Error(`Could not add audioWorklet module: ${this.scriptSrc}`)}let e=this.context.createAnalyser();return e.fftSize=8192,e.smoothingTimeConstant=.1,this.analyser=e,!0}getFrequencies(e="frequency",t=-100,s=-30){if(!this.analyser)throw new Error("Not connected, please call .connect() first");return B.getFrequencies(this.analyser,this.sampleRate,null,e,t,s)}_start(){let e=new AudioWorkletNode(this.context,"stream_processor");return e.connect(this.context.destination),e.port.onmessage=t=>{let{event:s}=t.data;if(s==="stop")this.onStop?.(),e.disconnect(),this.stream=null;else if(s==="offset"){let{requestId:r,trackId:n,offset:a}=t.data,c=a/this.sampleRate;this.trackSampleOffsets[r]={trackId:n,offset:a,currentTime:c};}},this.analyser.disconnect(),e.connect(this.analyser),this.stream=e,!0}add16BitPCM(e,t="default"){if(typeof t!="string")throw new Error("trackId must be a string");if(this.interruptedTrackIds[t])return;this.stream||this._start();let s;if(e instanceof Int16Array)s=e;else if(e instanceof ArrayBuffer)s=new Int16Array(e);else throw new Error("argument must be Int16Array or ArrayBuffer");return this.stream.port.postMessage({event:"write",buffer:s,trackId:t}),s}async getTrackSampleOffset(e=!1){if(!this.stream)return null;let t=crypto.randomUUID();this.stream.port.postMessage({event:e?"interrupt":"offset",requestId:t});let s;for(;!s;)s=this.trackSampleOffsets[t],await new Promise(n=>setTimeout(()=>n(),1));let{trackId:r}=s;return e&&r&&(this.interruptedTrackIds[r]=!0),s}async interrupt(){return this.getTrackSampleOffset(!0)}};globalThis.WavStreamPlayer=z;var fe=atom({key:"ThreadIdToResume",default:void 0}),Qe=atom({key:"ResumeThreadErrorState",default:void 0}),de=atom({key:"ChatProfile",default:void 0}),Ke=atom({key:"SessionId",default:v4()}),re=selector({key:"SessionIdSelector",get:({get:o})=>o(Ke),set:({set:o},e)=>o(Ke,e instanceof DefaultValue?v4():e)}),H=atom({key:"Session",dangerouslyAllowMutability:!0,default:void 0}),W=atom({key:"Actions",default:[]}),K=atom({key:"Messages",dangerouslyAllowMutability:!0,default:[]}),Ye=atom({key:"Commands",default:[]}),Xe=atom({key:"Modes",default:[]}),he=atom({key:"TokenCount",default:0}),G=atom({key:"Loading",default:!1}),J=atom({key:"AskUser",default:void 0}),pe=atom({key:"WavRecorder",dangerouslyAllowMutability:!0,default:new N}),me=atom({key:"WavStreamPlayer",dangerouslyAllowMutability:!0,default:new z}),ge=atom({key:"AudioConnection",default:"off"}),ye=atom({key:"isAiSpeaking",default:!1}),Se=atom({key:"CallFn",default:void 0}),j=atom({key:"ChatSettings",default:[]}),Ee=selector({key:"ChatSettingsValue/Default",get:({get:o})=>{let e=o(j),t=(s,r)=>(Array.isArray(s)&&s.forEach(n=>{n&&(Array.isArray(n?.inputs)&&n.inputs.length>0?t(n.inputs,r):n?.id!==void 0&&(r[n.id]=n.initial));}),r);return t(e,{})}}),O=atom({key:"ChatSettingsValue",default:Ee}),Q=atom({key:"DisplayElements",default:[]}),Y=atom({key:"TasklistElements",default:[]}),X=atom({key:"FirstUserInteraction",default:void 0}),Ze=atom({key:"User",default:void 0}),et=atom({key:"ChainlitConfig",default:void 0}),tt=atom({key:"AuthConfig",default:void 0}),st=atom({key:"ThreadHistory",default:{threads:void 0,currentThreadId:void 0,timeGroupedThreads:void 0,pageInfo:void 0},effects:[({setSelf:o,onSet:e})=>{e((t,s)=>{let r=t?.timeGroupedThreads;t?.threads&&!isEqual(t.threads,s?.timeGroupedThreads)&&(r=$e(t.threads)),o({...t,timeGroupedThreads:r});});}]}),we=atom({key:"SideView",default:void 0}),Z=atom({key:"CurrentThreadId",default:void 0}),Dt=o=>({setSelf:e,onSet:t})=>{let s=localStorage.getItem(o);if(s!=null)try{e(JSON.parse(s));}catch(r){console.error(`Error parsing localStorage value for key "${o}":`,r);}t((r,n,a)=>{a?localStorage.removeItem(o):localStorage.setItem(o,JSON.stringify(r));});},nt=atom({key:"Mcp",default:[],effects:[Dt("mcp_storage_key")]});var _s=()=>{let o=useRecoilValue(G),e=useRecoilValue(Q),t=useRecoilValue(Y),s=useRecoilValue(W),r=useRecoilValue(H),n=useRecoilValue(J),a=useRecoilValue(Se),c=useRecoilValue(j),u=useRecoilValue(O),p=useRecoilValue(Ee),f=r?.socket.connected&&!r?.error,d=!f||o||n?.spec.type==="file"||n?.spec.type==="action"||n?.spec.type==="element";return {actions:s,askUser:n,callFn:a,chatSettingsDefaultValue:p,chatSettingsInputs:c,chatSettingsValue:u,connected:f,disabled:d,elements:e,error:r?.error,loading:o,tasklists:t}};var Ds=o=>{let e=[];for(let t of o)e=R(e,t);return e},Us=(o,e)=>{if(o.length-1===e)return !0;for(let t=e+1;t<o.length;t++)if(!o[t].streaming)return !1;return !0},R=(o,e)=>it(o,e.id)?Ie(o,e.id,e):"parentId"in e&&e.parentId?ot(o,e.parentId,e):"indent"in e&&e.indent&&e.indent>0?rt(o,e.indent,e):[...o,e],rt=(o,e,t,s=0)=>{if(o.length===0)return [t];let r=o.length-1,n=o[r],a=n.steps||[];if(s+1===e){let c={...n,steps:[...a,t]},u=[...o];return u[r]=c,u}else {let c=rt(a,e,t,s+1);if(c===a)return o;let u=[...o];return u[r]={...n,steps:c},u}},ot=(o,e,t)=>{let s=!1,r=o.map(n=>{if(isEqual(n.id,e))return s=!0,{...n,steps:n.steps?[...n.steps,t]:[t]};if(it(o,e)&&n.steps){let a=ot(n.steps,e,t);if(a!==n.steps)return s=!0,{...n,steps:a}}return n});return s?r:o},at=(o,e)=>{for(let t of o){if(isEqual(t.id,e))return t;if(t.steps&&t.steps.length>0){let s=at(t.steps,e);if(s)return s}}},it=(o,e)=>at(o,e)!==void 0,Ie=(o,e,t)=>{let s=!1,r=o.map(n=>{if(isEqual(n.id,e))return s=!0,{...n,...t};if(n.steps){let a=Ie(n.steps,e,t);if(a!==n.steps)return s=!0,{...n,steps:a}}return n});return s?r:o},_e=(o,e)=>{let t=!1,s=o.reduce((r,n)=>{if(n.id===e)return t=!0,r;if(n.steps){let a=_e(n.steps,e);if(a!==n.steps)return t=!0,r.push({...n,steps:a}),r}return r.push(n),r},[]);return t?s:o},Re=(o,e,t,s,r)=>{let n=!1,a=o.map(c=>{if(isEqual(c.id,e)){n=!0;let u={...c};return "content"in u&&u.content!==void 0?s?u.content=t:u.content+=t:r?"input"in u&&u.input!==void 0&&(s?u.input=t:u.input+=t):"output"in u&&u.output!==void 0&&(s?u.output=t:u.output+=t),u}else if(c.steps){let u=Re(c.steps,e,t,s,r);if(u!==c.steps)return n=!0,{...c,steps:u}}return c});return n?a:o};var L=()=>{let[o,e]=useRecoilState(tt),[t,s]=useRecoilState(Ze),r=useSetRecoilState(st);return {authConfig:o,setAuthConfig:e,user:t,setUser:s,setThreadHistory:r}};var Vt=async(o,e)=>(await o.get(e))?.json(),jt=o=>{let e=new te("","webapp");return Object.assign(e,o),e};function ee(o,{...e}={}){let t=useContext(q),{setUser:s}=L(),r=useMemo(()=>([a])=>{e.onErrorRetry||(e.onErrorRetry=(...u)=>{let[p]=u;if(p.status===401){s(null);return}return SWRConfig.defaultValue.onErrorRetry(...u)});let c=jt(t);return c.on401=c.onError=void 0,Vt(c,a)},[t]),n=useMemo(()=>o?[o]:null,[o]);return Lt(n,r,e)}var lt=()=>{let{authConfig:o,setAuthConfig:e}=L(),{data:t,isLoading:s}=ee(o?null:"/auth/config");return useEffect(()=>{t&&e(t);},[t,e]),{authConfig:o,isLoading:s}};var ft=()=>{let o=useContext(q),{setUser:e,setThreadHistory:t}=L();return {logout:async(r=!1)=>{await o.logout(),e(void 0),t(void 0),r&&window.location.reload();}}};var ht=()=>{let{user:o,setUser:e}=L(),{data:t,error:s,mutate:r}=ee("/user");return useEffect(()=>{t&&e(t);},[t,e]),useEffect(()=>{s&&e(null);},[s]),{user:o,setUserFromAPI:r}};var pt=()=>{let{authConfig:o}=lt(),{logout:e}=ft(),{user:t,setUserFromAPI:s}=ht(),r=!!o&&(!o.requireLogin||t!==void 0);return o&&!o.requireLogin?{data:o,user:null,isReady:r,isAuthenticated:!0,logout:()=>Promise.resolve(),setUserFromAPI:()=>Promise.resolve()}:{data:o,user:t,isReady:r,isAuthenticated:!!t,logout:e,setUserFromAPI:s}};var Ae=class extends Error{constructor(t,s,r){super(t);this.status=s,this.detail=r;}toString(){return this.detail?`${this.message}: ${this.detail}`:this.message}},Fe=class{constructor(e,t,s,r,n){this.httpEndpoint=e;this.type=t;this.additionalQueryParams=s;this.on401=r;this.onError=n;}buildEndpoint(e){let t=`${this.httpEndpoint}${e}`;this.httpEndpoint.endsWith("/")&&(t=`${this.httpEndpoint.slice(0,-1)}${e}`);let s=new URL(t);if(this.additionalQueryParams){let r=new URLSearchParams(this.additionalQueryParams),n=s.search?"&":"?";s.search=s.search+`${n}${r.toString()}`;}return s.toString()}async getDetailFromErrorResponse(e){try{return (await e.json())?.detail}catch(t){console.error("Unable to parse error response",t);}}handleRequestError(e){e instanceof Ae&&(e.status===401&&this.on401&&this.on401(),this.onError&&this.onError(e)),console.error(e);}async fetch(e,t,s,r,n={}){try{let a;s instanceof FormData?a=s:(n["Content-Type"]="application/json",a=s?JSON.stringify(s):null);let c=await fetch(this.buildEndpoint(t),{method:e,credentials:"include",headers:n,signal:r,body:a});if(!c.ok){let u=await this.getDetailFromErrorResponse(c);throw new Ae(c.statusText,c.status,u)}return c}catch(a){throw this.handleRequestError(a),a}}async get(e){return await this.fetch("GET",e)}async post(e,t,s){return await this.fetch("POST",e,t,s)}async put(e,t){return await this.fetch("PUT",e,t)}async patch(e,t){return await this.fetch("PATCH",e,t)}async delete(e,t){return await this.fetch("DELETE",e,t)}},te=class extends Fe{async headerAuth(){return (await this.post("/auth/header",{})).json()}async jwtAuth(e){return (await this.fetch("POST","/auth/jwt",void 0,void 0,{Authorization:`Bearer ${e}`})).json()}async stickyCookie(e){return (await this.fetch("POST","/set-session-cookie",{session_id:e})).json()}async passwordAuth(e){return (await this.post("/login",e)).json()}async getUser(){return (await this.get("/user")).json()}async logout(){return (await this.post("/logout",{})).json()}async setFeedback(e,t){return (await this.put("/feedback",{feedback:e,sessionId:t})).json()}async deleteFeedback(e){return (await this.delete("/feedback",{feedbackId:e})).json()}async listThreads(e,t){return (await this.post("/project/threads",{pagination:e,filter:t})).json()}async renameThread(e,t){return (await this.put("/project/thread",{threadId:e,name:t})).json()}async deleteThread(e){return (await this.delete("/project/thread",{threadId:e})).json()}uploadFile(e,t,s,r){let n=new XMLHttpRequest;n.withCredentials=!0;let a=new Promise((c,u)=>{let p=new FormData;p.append("file",e);let f=r?`&ask_parent_id=${r}`:"";n.open("POST",this.buildEndpoint(`/project/file?session_id=${s}${f}`),!0),n.upload.onprogress=function(d){if(d.lengthComputable){let g=d.loaded/d.total*100;t(g);}},n.onload=function(){if(n.status===200){let g=JSON.parse(n.responseText);c(g);return}let d=n.getResponseHeader("Content-Type");if(d&&d.includes("application/json")){let g=JSON.parse(n.responseText);u(g.detail);}else u("Upload failed");},n.onerror=function(){u("Upload error");},n.send(p);});return {xhr:n,promise:a}}async callAction(e,t){return (await this.post("/project/action",{sessionId:t,action:e})).json()}async updateElement(e,t){return (await this.put("/project/element",{sessionId:t,element:e})).json()}async deleteElement(e,t){return (await this.delete("/project/element",{sessionId:t,element:e})).json()}async connectStdioMCP(e,t,s){return (await this.post("/mcp",{sessionId:e,name:t,fullCommand:s,clientType:"stdio"})).json()}async connectSseMCP(e,t,s,r){return (await this.post("/mcp",{sessionId:e,name:t,url:s,...r?{headers:r}:{},clientType:"sse"})).json()}async connectStreamableHttpMCP(e,t,s,r){return (await this.post("/mcp",{sessionId:e,name:t,url:s,...r?{headers:r}:{},clientType:"streamable-http"})).json()}async disconnectMcp(e,t){return (await this.delete("/mcp",{sessionId:e,name:t})).json()}getElementUrl(e,t){let s=`?session_id=${t}`;return this.buildEndpoint(`/project/file/${e}${s}`)}getLogoEndpoint(e,t){return t||this.buildEndpoint(`/logo?theme=${e}`)}getOAuthEndpoint(e){return this.buildEndpoint(`/auth/oauth/${e}`)}async shareThread(e,t){return (await this.put("/project/thread/share",{threadId:e,isShared:t})).json()}};var mn=void 0,q=createContext(new te("http://localhost:8000","webapp"));var mt=()=>{let o=useContext(q),e=useRecoilValue(H),t=useRecoilValue(J),s=useRecoilValue(re),r=useResetRecoilState(j),n=useResetRecoilState(re),a=useResetRecoilState(O),c=useSetRecoilState(X),u=useSetRecoilState(G),p=useSetRecoilState(K),f=useSetRecoilState(Q),d=useSetRecoilState(Y),g=useSetRecoilState(W),y=useSetRecoilState(he),S=useSetRecoilState(fe),w=useSetRecoilState(we),F=useSetRecoilState(Z),se=useCallback(()=>{e?.socket.emit("clear_session"),e?.socket.disconnect(),S(void 0),n(),c(void 0),p([]),f([]),d([]),g([]),y(0),r(),a(),w(void 0),F(void 0);},[e]),V=useCallback((I,x=[])=>{I.id||(I.id=v4()),I.createdAt||(I.createdAt=new Date().toISOString()),p(U=>R(U,I)),e?.socket.emit("client_message",{message:I,fileReferences:x});},[e?.socket]),v=useCallback(I=>{e?.socket.emit("edit_message",{message:I});},[e?.socket]),ne=useCallback(I=>{e?.socket.emit("window_message",I);},[e?.socket]),ae=useCallback(()=>{e?.socket.emit("audio_start");},[e?.socket]),be=useCallback((I,x,U,ve)=>{e?.socket.emit("audio_chunk",{isStart:I,mimeType:x,elapsedTime:U,data:ve});},[e?.socket]),xe=useCallback(()=>{e?.socket.emit("audio_end");},[e?.socket]),$=useCallback(I=>{t&&(t.parentId&&(I.parentId=t.parentId),p(x=>R(x,I)),t.callback(I));},[t]),ie=useCallback(I=>{e?.socket.emit("chat_settings_change",I);},[e?.socket]),D=useCallback(()=>{p(I=>I.map(x=>(x.streaming=!1,x))),u(!1),e?.socket.emit("stop");},[e?.socket]);return {uploadFile:useCallback((I,x,U)=>o.uploadFile(I,x,s,U),[s]),clear:se,replyMessage:$,sendMessage:V,editMessage:v,windowMessage:ne,startAudioStream:ae,sendAudioChunk:be,endAudioStream:xe,stopTask:D,setIdToResume:S,updateChatSettings:ie}};var vn=()=>{let o=useRecoilValue(K),e=useRecoilValue(X);return {threadId:useRecoilValue(Z),messages:o,firstInteraction:e}};var Bn=()=>{let o=useContext(q),e=useRecoilValue(re),[t,s]=useRecoilState(H),r=useSetRecoilState(ye),n=useSetRecoilState(ge),a=useResetRecoilState(O),c=useSetRecoilState(O),u=useSetRecoilState(X),p=useSetRecoilState(G),f=useSetRecoilState(nt),d=useRecoilValue(me),g=useRecoilValue(pe),y=useSetRecoilState(K),S=useSetRecoilState(J),w=useSetRecoilState(Se),F=useSetRecoilState(Ye),se=useSetRecoilState(Xe),V=useSetRecoilState(we),v=useSetRecoilState(Q),ne=useSetRecoilState(Y),ae=useSetRecoilState(W),be=useSetRecoilState(j),xe=useSetRecoilState(he),[$,ie]=useRecoilState(de),D=useRecoilValue(fe),Oe=useSetRecoilState(Qe),[I,x]=useRecoilState(Z);useEffect(()=>{t?.socket&&(t.socket.auth.threadId=I||"");},[I]);let U=useCallback(async({transports:wt,userEnv:kt})=>{let{protocol:It,host:At,pathname:Te}=new URL(o.httpEndpoint),Ct=`${It}//${At}`,bt=Te&&Te!=="/"?`${Te}/ws/socket.io`:"/ws/socket.io";try{await o.stickyCookie(e);}catch(i){console.error(`Failed to set sticky session cookie: ${i}`);}let m=Qt(Ct,{path:bt,withCredentials:!0,transports:wt,auth:{clientType:o.type,sessionId:e,threadId:D||"",userEnv:JSON.stringify(kt),chatProfile:$?encodeURIComponent($):""}});s(i=>(i?.socket?.removeAllListeners(),i?.socket?.close(),{socket:m})),m.on("connect",()=>{m.emit("connection_successful"),s(i=>({...i,error:!1})),f(i=>i.map(l=>{let h;return l.clientType==="sse"?h=o.connectSseMCP(e,l.name,l.url):l.clientType==="streamable-http"?h=o.connectStreamableHttpMCP(e,l.name,l.url,l.headers||{}):h=o.connectStdioMCP(e,l.name,l.command),h.then(async({success:A,mcp:b})=>{f(Pe=>Pe.map(ce=>ce.name===b.name?{...ce,status:A?"connected":"failed",tools:b?b.tools:ce.tools}:ce));}).catch(()=>{f(A=>A.map(b=>b.name===l.name?{...b,status:"failed"}:b));}),{...l,status:"connecting"}}));}),m.on("connect_error",i=>{s(l=>({...l,error:!0}));}),m.on("task_start",()=>{p(!0);}),m.on("task_end",()=>{p(!1);}),m.on("reload",()=>{m.emit("clear_session"),window.location.reload();}),m.on("audio_connection",async i=>{if(i==="on"){let l=!0,h=Date.now(),A="pcm16";await g.begin(),await d.connect(),await g.record(async b=>{let Pe=Date.now()-h;m.emit("audio_chunk",{isStart:l,mimeType:A,elapsedTime:Pe,data:b.mono}),l=!1;}),d.onStop=()=>r(!1);}else await g.end(),await d.interrupt();n(i);}),m.on("audio_chunk",i=>{d.add16BitPCM(i.data,i.track),r(!0);}),m.on("audio_interrupt",()=>{d.interrupt();}),m.on("resume_thread",i=>{let l=!!i?.metadata?.viewer_read_only;!l&&D&&i.id!==D&&(window.location.href=`/thread/${i.id}`),!l&&D&&x(i.id);let h=[];for(let b of i.steps)h=R(h,b);i.metadata?.chat_profile&&ie(i.metadata?.chat_profile),i.metadata?.chat_settings&&c(i.metadata?.chat_settings),y(h);let A=i.elements||[];ne(A.filter(b=>b.type==="tasklist")),v(A.filter(b=>["avatar","tasklist"].indexOf(b.type)===-1));}),m.on("resume_thread_error",i=>{Oe(i);}),m.on("new_message",i=>{y(l=>R(l,i));}),m.on("first_interaction",i=>{u(i.interaction),x(i.thread_id);}),m.on("update_message",i=>{y(l=>Ie(l,i.id,i));}),m.on("delete_message",i=>{y(l=>_e(l,i.id));}),m.on("stream_start",i=>{y(l=>R(l,i));}),m.on("stream_token",({id:i,token:l,isSequence:h,isInput:A})=>{y(b=>Re(b,i,l,h,A));}),m.on("ask",({msg:i,spec:l},h)=>{S({spec:l,callback:h,parentId:i.parentId}),y(A=>R(A,i)),p(!1);}),m.on("ask_timeout",()=>{S(void 0),p(!1);}),m.on("clear_ask",()=>{S(void 0);}),m.on("call_fn",({name:i,args:l},h)=>{w({name:i,args:l,callback:h});}),m.on("clear_call_fn",()=>{w(void 0);}),m.on("call_fn_timeout",()=>{w(void 0);}),m.on("chat_settings",i=>{be(i),a();}),m.on("set_commands",i=>{F(i);}),m.on("set_modes",i=>{se(i);}),m.on("set_sidebar_title",i=>{V(l=>l?.title===i?l:{title:i,elements:l?.elements||[]});}),m.on("set_sidebar_elements",({elements:i,key:l})=>{i.length?(i.forEach(h=>{!h.url&&h.chainlitKey&&(h.url=o.getElementUrl(h.chainlitKey,e));}),V(h=>h?.key===l?h:{title:h?.title||"",elements:i,key:l})):V(void 0);}),m.on("element",i=>{!i.url&&i.chainlitKey&&(i.url=o.getElementUrl(i.chainlitKey,e)),i.type==="tasklist"?ne(l=>{let h=l.findIndex(A=>A.id===i.id);return h===-1?[...l,i]:[...l.slice(0,h),i,...l.slice(h+1)]}):v(l=>{let h=l.findIndex(A=>A.id===i.id);return h===-1?[...l,i]:[...l.slice(0,h),i,...l.slice(h+1)]});}),m.on("remove_element",i=>{v(l=>l.filter(h=>h.id!==i.id)),ne(l=>l.filter(h=>h.id!==i.id));}),m.on("action",i=>{ae(l=>[...l,i]);}),m.on("remove_action",i=>{ae(l=>{let h=l.findIndex(A=>A.id===i.id);return h===-1?l:[...l.slice(0,h),...l.slice(h+1)]});}),m.on("token_usage",i=>{xe(l=>l+i);}),m.on("window_message",i=>{window.parent&&window.parent.postMessage(i,"*");}),m.on("toast",i=>{if(!i.message){console.warn("No message received for toast.");return}switch(i.type){case"info":toast.info(i.message);break;case"error":toast.error(i.message);break;case"success":toast.success(i.message);break;case"warning":toast.warning(i.message);break;default:toast(i.message);break}});},[s,e,D,$]),ve=useCallback(debounce(U,200),[U]),St=useCallback(()=>{t?.socket&&(t.socket.removeAllListeners(),t.socket.close());},[t]);return {connect:ve,disconnect:St,session:t,sessionId:e,chatProfile:$,idToResume:D,setChatProfile:ie}};var $n=()=>{let[o,e]=useRecoilState(ge),t=useRecoilValue(pe),s=useRecoilValue(me),r=useRecoilValue(ye),{startAudioStream:n,endAudioStream:a}=mt(),c=useCallback(async()=>{e("connecting"),await n();},[n]),u=useCallback(async()=>{e("off"),await t.end(),await s.interrupt(),await a();},[a,t,s]);return {startConversation:c,endConversation:u,audioConnection:o,isAiSpeaking:r,wavRecorder:t,wavStreamPlayer:s}};var Gn=()=>{let[o,e]=useRecoilState(et),{isAuthenticated:t}=pt(),s=useRecoilValue(de),r=navigator.language||"en-US",n=useRef(s),a=t?`/project/settings?language=${r}${s?`&chat_profile=${encodeURIComponent(s)}`:""}`:null,c=t&&!o,{data:u,error:p,isLoading:f}=ee(c?a:null);return useEffect(()=>{u&&e(u);},[u,e]),useEffect(()=>{n.current!==s&&(e(void 0),n.current=s);},[s,e]),{config:o,error:p,isLoading:f,language:r}};var je=new WeakMap,ts=(o,e,t=!1,s=!1)=>{let r,n,a;if(s&&(n=e.toString(),a=t.toString(),r=je.has(o)?je.get(o):{},je.set(o,r),r[n]=r[n]||{},r[n][a]))return r[n][a];let c=o.length,u=new Array(e);if(e<=c){u.fill(0);let p=new Array(e).fill(0);for(let f=0;f<c;f++){let d=Math.floor(f*(e/c));t?u[d]=Math.max(u[d],Math.abs(o[f])):u[d]+=Math.abs(o[f]),p[d]++;}if(!t)for(let f=0;f<u.length;f++)u[f]=u[f]/p[f];}else for(let p=0;p<e;p++){let f=p*(c-1)/(e-1),d=Math.floor(f),g=Math.ceil(f),y=f-d;g>=c?u[p]=o[c-1]:u[p]=o[d]*(1-y)+o[g]*y;}return s&&(r[n][a]=u),u},ss={drawBars:(o,e,t,s,r,n=0,a=0,c=0,u=!1)=>{n=Math.floor(Math.min(n,(t-c)/(Math.max(a,1)+c))),n||(n=Math.floor((t-c)/(Math.max(a,1)+c))),a||(a=(t-c)/n-c);let p=ts(e,n,!0);for(let f=0;f<n;f++){let d=Math.abs(p[f]),g=Math.max(1,d*s),y=c+f*(a+c),S=u?(s-g)/2:s-g,w=Math.min(a/2,g/2);o.fillStyle=r,o.beginPath(),o.moveTo(y+w,S),o.lineTo(y+a-w,S),o.arcTo(y+a,S,y+a,S+w,w),o.lineTo(y+a,S+g-w),o.arcTo(y+a,S+g,y+a-w,S+g,w),o.lineTo(y+w,S+g),o.arcTo(y,S+g,y,S+g-w,w),o.lineTo(y,S+w),o.arcTo(y,S,y+w,S,w),o.closePath(),o.fill();}}};

export { Fe as APIBase, te as ChainlitAPI, q as ChainlitContext, Ae as ClientError, ss as WavRenderer, W as actionState, R as addMessage, ot as addMessageToParent, J as askUserState, ge as audioConnectionState, tt as authState, Se as callFnState, de as chatProfileState, Ee as chatSettingsDefaultValueSelector, j as chatSettingsInputsState, O as chatSettingsValueState, Ye as commandsState, et as configState, Z as currentThreadIdState, mn as defaultChainlitContext, _e as deleteMessageById, Q as elementState, Vt as fetcher, X as firstUserInteraction, it as hasMessageById, ye as isAiSpeakingState, Us as isLastMessage, G as loadingState, nt as mcpState, K as messagesState, Xe as modesState, Ds as nestMessages, Qe as resumeThreadErrorState, re as sessionIdState, H as sessionState, we as sideViewState, Y as tasklistState, st as threadHistoryState, fe as threadIdToResumeState, he as tokenCountState, Ie as updateMessageById, Re as updateMessageContentById, ee as useApi, $n as useAudio, pt as useAuth, _s as useChatData, mt as useChatInteract, vn as useChatMessages, Bn as useChatSession, Gn as useConfig, Ze as userState, pe as wavRecorderState, me as wavStreamPlayerState };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map